BASELIVRE FACTO
(j'ai bidouillé dans base livre mais le code qui marche c'est baselivre facto)

- passé request.get en verify=False, avec quelques en têtes pour dire de ne pas aficher les avertissements, sinon ça ne marche jamais avec les urls du prof qui ne sont pas bien vérifiées

- la méthode type() ne trouvait jamais letype / disait tout le temps "autre".
changé "application/epub+zip" vers "EPUB document" et idem pour pdf, ça fonctionne.

-""PyPDF2.errors.DeprecationError: getDocumentInfo is deprecated and was removed in PyPDF2 3.0.0. Use metadata instead."""
Remplacé getDocumentinfo par metadata

- dans self.auteur, l'auteur s'appelle 'creator' si c'est un epub et 'author' si c'est un pdf, j'ai mis la condition qui va bien

- epub.read ne fonctionne que sur des fichiers locaux, ça renvoie des erreurs si on prend une url depuis un site
donc j'ai ajouté une méthode "ajouter depuis url" qui télécharge le livre et change self.ressource vers ce nouveau lien, qui est maintenant local. Elle s'active si est_url renvoie TRUE dans le init.

BASE_BIBLI

- 'format' désigne le format du rapport, pas de celui livres qu'on doit compter dans le rapport ;)


- le rapport créait un fichier texte, pas un pdf ou un epub mais ça doit venir de la même méprise que ci dessus. Du coup j'ai corrigé en utilisant reportlab et ebooklib, comme tu avais déjà inclu, j'imagine du coup que tu y avais déjà pensé ?

- dans le init, j'ai changé le cas où self.path n'existe pas, pour que python créé le dossier au lieu de lever une erreur (avec os.mkdir)

- dans rapport auteurs, j'ai enlevé le 'livre_info' qui faisait que la variable rapport auteurs était un dictionnaire de tableau de dictionnaires (ça casse la tête....)
A la place, maintenant rapport_auteur est un dictionnaire où les noms sont les auteurs, et chaque élément contient un tableau d'objets BaseLivre qui sont les livres de l'auteur.
Ca facilite pour itérer ensuite quand on créé le pdf ou l'epub.



